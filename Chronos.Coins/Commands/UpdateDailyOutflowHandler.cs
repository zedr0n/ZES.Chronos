/// <filename>
///     UpdateDailyOutflowHandler.cs
/// </filename>

// <auto-generated/>

using System;
using System.Collections.Generic;
using System.Linq;
using System.Reactive.Linq;
using System.Threading.Tasks;
using Chronos.Core;
using Chronos.Core.Commands;
using Chronos.Core.Json;
using NodaTime;
using NodaTime.Text;
using ZES.Infrastructure;
using ZES.Infrastructure.Alerts;
using ZES.Infrastructure.Domain;
using ZES.Infrastructure.Net;
using ZES.Interfaces.Domain;
using ZES.Interfaces.Net;
using ZES.Interfaces.Pipes;

namespace Chronos.Coins.Commands
{
  public class UpdateDailyOutflowHandler : ZES.Infrastructure.Domain.CommandHandlerBase<UpdateDailyOutflow, Wallet>
  {
    private readonly ICommandHandler<RequestJson<TxResults>> _handler;
    private readonly ICommandHandler<RequestJson<AddressInfo>> _addressHandler;
    private readonly ICommandHandler<RetroactiveCommand<ChangeWalletBalance>> _balanceHandler;
    private readonly IMessageQueue _messageQueue;
    private readonly IEsRepository<IAggregate> _repository;

    private readonly string _server = null;
    private string _firstTx = null;
    
    public UpdateDailyOutflowHandler(ZES.Interfaces.Domain.IEsRepository<ZES.Interfaces.Domain.IAggregate> repository, ICommandHandler<RequestJson<TxResults>> handler, IMessageQueue messageQueue, ICommandHandler<RetroactiveCommand<ChangeWalletBalance>> balanceHandler, ICommandHandler<RequestJson<AddressInfo>> addressHandler)
      : base(repository)
    {
      _repository = repository;
      _handler = handler;
      _messageQueue = messageQueue;
      _balanceHandler = balanceHandler;
      _addressHandler = addressHandler;
      if (Environment.GetEnvironmentVariable("SERVER") != "")
        _server = Environment.GetEnvironmentVariable("SERVER");
    }

    public override async Task Handle(UpdateDailyOutflow command)
    {
      if (_server == null)
      {
        command.StoreInLog = false;
        return;
      }
      
      var root = await _repository.Find<Wallet>(command.Target);
      if (root == null)
        throw new ArgumentNullException(nameof(command.Address));

      var url = await GetTxUrl(command.Address, command.Index);
      await _handler.Handle(new RequestJson<TxResults>(command.Target, url));
      var res = await _messageQueue.Alerts.OfType<JsonRequestCompleted<TxResults>>().FirstOrDefaultAsync(r => r.RequestorId == command.Target).Timeout(TimeSpan.FromMinutes(1));
      if (res.Data == null)
        throw new InvalidOperationException();

      var outflows = new Dictionary<Instant, (Instant time, double amount)>();
      foreach (var tx in res.Data)
      {
        var dateTime = Instant.FromUnixTimeMilliseconds(tx.ReceiveTime).InUtc().LocalDateTime;
        var date = new LocalDate(dateTime.Year, dateTime.Month, dateTime.Day);
        var instant = date.AtMidnight().InUtc().ToInstant();
        var amount = tx.Amount;
        if (outflows.ContainsKey(instant))
          amount += outflows[instant].amount;
        outflows[instant] = (Instant.FromUnixTimeMilliseconds(tx.ReceiveTime), amount);
      }

      ICommand changeBalanceCommand = null;
      var idx = 0;
      foreach (var v in outflows)
      {
        changeBalanceCommand = new RetroactiveCommand<ChangeWalletBalance>(new ChangeWalletBalance(command.Address, new Quantity(-v.Value.amount, new Asset("Hycon", "HYC", Asset.Type.Coin)), $"Out{command.Index}_{idx}"), v.Value.time);
        await _balanceHandler.Handle(changeBalanceCommand);
        ++idx;
      }

      command.StoreInLog = false;
      command.EventType = changeBalanceCommand?.EventType;
    }

    protected virtual async Task<string> GetTxUrl(string address, int index)
    {
      if (_firstTx == null)
        _firstTx = await GetFirstTx(address);
      
      var url = $"http://{_server}/api/v1/nextTxs/{address}/{_firstTx}/{index}";
      return url;
    }

    protected virtual string GetAddressInfoUrl(string address)
    {
      var url = $"http://{_server}/api/v1/address/{address}";
      return url;
    }
    
    private async Task<string> GetFirstTx(string address)
    {
      var url = GetAddressInfoUrl(address);
      await _addressHandler.Handle(new RequestJson<AddressInfo>(address, url));
      
      var res = await _messageQueue.Alerts.OfType<JsonRequestCompleted<AddressInfo>>().FirstOrDefaultAsync(r => r.RequestorId == address).Timeout(TimeSpan.FromMinutes(1));
      if (res.Data == null)
        throw new InvalidOperationException();

      return res.Data.Txs.First().Hash;
    }
    
    protected override void Act (Wallet wallet, UpdateDailyOutflow command)
    {
      throw new NotImplementedException();
    }
  }
}

