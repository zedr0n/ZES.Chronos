/// <filename>
///     UpdateDailyOutflowHandler.cs
/// </filename>

// <auto-generated/>

using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using Chronos.Core;
using Chronos.Core.Json;
using NodaTime;
using ZES.Infrastructure.Domain;
using ZES.Interfaces;
using ZES.Interfaces.Domain;
using ZES.Interfaces.Pipes;

namespace Chronos.Coins.Commands
{
  public abstract class UpdateDailyOutflowHandler : ZES.Infrastructure.Domain.CommandHandlerBase<UpdateDailyOutflow, Wallet>
  {
    private readonly ICommandHandler<RetroactiveCommand<ChangeWalletBalance>> _balanceHandler;
    private readonly IMessageQueue _messageQueue;
    private readonly IEsRepository<IAggregate> _repository;
    private readonly ILog _log;

    protected string Server;
    
    public UpdateDailyOutflowHandler(ZES.Interfaces.Domain.IEsRepository<ZES.Interfaces.Domain.IAggregate> repository, IMessageQueue messageQueue, ICommandHandler<RetroactiveCommand<ChangeWalletBalance>> balanceHandler, ILog log)
      : base(repository)
    {
      _repository = repository;
      _messageQueue = messageQueue;
      _balanceHandler = balanceHandler;
      _log = log;
      if (Environment.GetEnvironmentVariable("SERVER") != "")
        Server = Environment.GetEnvironmentVariable("SERVER");
    }

    public override async Task Handle(UpdateDailyOutflow command)
    {
      if (!Api.TryGetServer(command.UseRemote, out Server))
        return;

      var root = await _repository.Find<Wallet>(command.Target);
      if (root == null)
        throw new ArgumentNullException(nameof(command.Address));

      var txResults = await GetTransactions(command);
      
      var outflows = new Dictionary<Instant, (Instant time, double amount)>();
      foreach (var tx in txResults)
      {
        var dateTime = Instant.FromUnixTimeMilliseconds(tx.ReceiveTime).InUtc().LocalDateTime;
        var date = new LocalDate(dateTime.Year, dateTime.Month, dateTime.Day);
        var instant = date.AtMidnight().InUtc().ToInstant();
        var amount = tx.Amount;
        if (tx.To == command.Target)
          amount *= -1;
        
        if (outflows.ContainsKey(instant))
          amount += outflows[instant].amount;
        outflows[instant] = (Instant.FromUnixTimeMilliseconds(tx.ReceiveTime), amount);
      }

      ICommand changeBalanceCommand = null;
      var idx = 0;
      foreach (var v in outflows)
      {
        changeBalanceCommand = new RetroactiveCommand<ChangeWalletBalance>(new ChangeWalletBalance(command.Address, new Quantity(-v.Value.amount, new Asset("Hycon", "HYC", Asset.Type.Coin)), $"Out{command.Index}_{idx}"), v.Value.time);
        await _balanceHandler.Handle(changeBalanceCommand);
        ++idx;
      }

      command.EventType = changeBalanceCommand?.EventType;
    }

    /// <summary>
    /// Parse JSON list of transactions from API
    /// </summary>
    /// <param name="command">Input command</param>
    /// <returns>List of transactions</returns>
    protected abstract Task<IEnumerable<Tx>> GetTransactions(UpdateDailyOutflow command);

    protected override void Act (Wallet wallet, UpdateDailyOutflow command)
    {
      throw new NotImplementedException();
    }
  }
}

