/// <filename>
///     GenericAssetPriceHandler.cs
/// </filename>

// <auto-generated/>

using System;
using System.Globalization;
using System.Linq;
using System.Threading.Tasks;
using NodaTime;
using ZES.Infrastructure;
using ZES.Infrastructure.Alerts;
using ZES.Infrastructure.Domain;
using ZES.Infrastructure.Net;
using ZES.Infrastructure.Utils;
using ZES.Interfaces;
using ZES.Interfaces.Branching;
using ZES.Interfaces.Domain;
using ZES.Interfaces.Pipes;

namespace Chronos.Core.Queries
{
  [Transient]
  public class AssetPriceHandler : QueryHandlerBase<AssetPriceQuery, AssetPrice, AssetPairsInfo>
  {
    private readonly IQueryHandler<SingleAssetPriceQuery, SingleAssetPrice> _handler;
    private readonly ILog _log;
    private readonly IMessageQueue _messageQueue;
    private readonly IBranchManager _branchManager;

    public AssetPriceHandler(IProjectionManager manager, IQueryHandler<SingleAssetPriceQuery, SingleAssetPrice> handler, ILog log, IMessageQueue messageQueue, IBranchManager branchManager) 
      : base(manager)
    {
      _handler = handler;
      _log = log;
      _messageQueue = messageQueue;
      _branchManager = branchManager;
    }

    protected override async Task<AssetPrice> Handle(IProjection<AssetPairsInfo> projection, AssetPriceQuery query)
    {
      var price = 1.0;
      var fordom = AssetPair.Fordom(query.ForAsset, query.DomAsset);
      var info = projection.State;
      info.Tree.Log = _log;
      if (info.Pairs.ToList().Contains(fordom))
      {
        price = (await _handler.Handle(new SingleAssetPriceQuery(fordom))).Price;
      }
      else 
      {
        // try to triangulate the price
        var path = info.Tree.GetPath(query.ForAsset, query.DomAsset);
        if (path == null)
          throw new InvalidOperationException($"No path found from {query.ForAsset?.Ticker} to {query.DomAsset?.Ticker}");

        var timestamp = _branchManager.GetTime(query.Timeline != "" ? query.Timeline : _branchManager.ActiveBranch);
        foreach (var n in path)
        {
          var pathForDom = n.forAsset + n.domAsset;
          var isInverse = info.Pairs.Contains(n.domAsset + n.forAsset);
          if (isInverse)
            pathForDom = n.domAsset + n.forAsset;

          var pathResult = await _handler.Handle(new SingleAssetPriceQuery(pathForDom));

          if (pathResult.Timestamp.Minus(timestamp).Days > 0)
            throw new InvalidOperationException($"Stale pricing date for {pathForDom}");

          if (isInverse)
            pathResult.Price = 1.0 / pathResult.Price;
          
          price *= pathResult.Price;
        }
      }
      
      return new AssetPrice(price); 
    }
  }
}

