/// <filename>
///     GenericAssetPriceHandler.cs
/// </filename>

// <auto-generated/>

using System;
using System.Globalization;
using System.Linq;
using System.Threading.Tasks;
using NodaTime;
using ZES.Infrastructure;
using ZES.Infrastructure.Alerts;
using ZES.Infrastructure.Domain;
using ZES.Infrastructure.Net;
using ZES.Infrastructure.Utils;
using ZES.Interfaces;
using ZES.Interfaces.Branching;
using ZES.Interfaces.Domain;
using ZES.Interfaces.Pipes;

namespace Chronos.Core.Queries
{
  [Transient]
  public class AssetPriceHandler : QueryHandlerBase<AssetPriceQuery, AssetPrice, AssetPairsInfo>
  {
    private readonly IQueryHandler<SingleAssetPriceQuery, SingleAssetPrice> _handler;
    private readonly IQueryHandler<HistoricalQuery<SingleAssetPriceQuery, SingleAssetPrice>, SingleAssetPrice> _historicalHandler;
    private readonly ILog _log;
    private readonly IMessageQueue _messageQueue;
    private readonly IBranchManager _branchManager;

    public AssetPriceHandler(IProjectionManager manager, IQueryHandler<HistoricalQuery<SingleAssetPriceQuery, SingleAssetPrice>, SingleAssetPrice> historicalHandler, ILog log, IMessageQueue messageQueue, IBranchManager branchManager, IQueryHandler<SingleAssetPriceQuery, SingleAssetPrice> handler) 
      : base(manager)
    {
      _historicalHandler = historicalHandler;
      _log = log;
      _messageQueue = messageQueue;
      _branchManager = branchManager;
      _handler = handler;
    }

    protected override async Task<AssetPrice> Handle(IProjection<AssetPairsInfo> projection, AssetPriceQuery query)
    {
      var price = 1.0;
      var historical = false;
      var fordom = AssetPair.Fordom(query.ForAsset, query.DomAsset);
      var info = projection.State;
      info.Tree.Log = _log;
      var timestamp = query.Timestamp;
      if (query.Timeline != "")
        timestamp = _branchManager.GetTime(query.Timeline);
      else if (timestamp == default)
        timestamp = _branchManager.GetTime(_branchManager.ActiveBranch);
      else
        historical = true;
      
      if (info.Pairs.ToList().Contains(fordom))
      {
        SingleAssetPrice result = null;
        if (historical)
          result = await _historicalHandler.Handle(new HistoricalQuery<SingleAssetPriceQuery, SingleAssetPrice>(new SingleAssetPriceQuery(fordom), timestamp));
        else
          result = await _handler.Handle(new SingleAssetPriceQuery(fordom) { Timeline = query.Timeline });
        
        if (result == null || result.Timestamp.Minus(timestamp).Days > 0 || timestamp.Minus(result.Timestamp).Days > 0)
          throw new InvalidOperationException($"Stale pricing date for {fordom}");
        price = result.Price;
      }
      else 
      {
        // try to triangulate the price
        var path = info.Tree.GetPath(query.ForAsset, query.DomAsset);
        if (path == null)
          throw new InvalidOperationException($"No path found from {query.ForAsset?.Ticker} to {query.DomAsset?.Ticker}");

        foreach (var n in path)
        {
          var pathForDom = n.forAsset + n.domAsset;
          var isInverse = info.Pairs.Contains(n.domAsset + n.forAsset);
          if (isInverse)
            pathForDom = n.domAsset + n.forAsset;

          SingleAssetPrice pathResult = null;
          if (historical)
            pathResult = await _historicalHandler.Handle(new HistoricalQuery<SingleAssetPriceQuery, SingleAssetPrice>(new SingleAssetPriceQuery(pathForDom), timestamp));
          else
            pathResult = await _handler.Handle(new SingleAssetPriceQuery(pathForDom) { Timeline = query.Timeline });

          if (pathResult == null || pathResult.Timestamp.Minus(timestamp).Days > 0 || timestamp.Minus(pathResult.Timestamp).Days > 0)
            throw new InvalidOperationException($"Stale pricing date for {pathForDom}");

          if (isInverse)
            pathResult.Price = 1.0 / pathResult.Price;
          
          price *= pathResult.Price;
        }
      }
      
      return new AssetPrice(price, timestamp); 
    }
  }
}

