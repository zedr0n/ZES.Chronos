/// <filename>
///     GenericAssetPriceHandler.cs
/// </filename>

// <auto-generated/>

using System;
using System.Linq;
using System.Threading.Tasks;
using NodaTime;
using ZES.Infrastructure;
using ZES.Infrastructure.Domain;
using ZES.Infrastructure.Utils;
using ZES.Interfaces;
using ZES.Interfaces.Domain;

namespace Chronos.Core.Queries
{
  [Transient]
  public class GenericAssetPriceHandler : QueryHandlerBase<GenericAssetPriceQuery, GenericAssetPrice, AssetPairsInfo>
  {
    private readonly IQueryHandler<AssetPriceQuery, AssetPrice> _handler;
    private readonly ILog _log;

    public GenericAssetPriceHandler(IProjectionManager manager, IQueryHandler<AssetPriceQuery, AssetPrice> handler, ILog log) : base(manager)
    {
      _handler = handler;
      _log = log;
    }

    protected override async Task<GenericAssetPrice> Handle(IProjection<AssetPairsInfo> projection, GenericAssetPriceQuery query)
    {
      var price = 1.0;
      var fordom = AssetPair.Fordom(query.ForAsset, query.DomAsset);
      var info = projection.State;
      info.Tree.Log = _log;
      if (info.Pairs.ToList().Contains(fordom))
      {
        price = (await _handler.Handle(new AssetPriceQuery(fordom))).Price;
      }
      else 
      {
        // try to triangulate the price
        var path = info.Tree.GetPath(query.ForAsset, query.DomAsset);
        if (path == null)
          throw new InvalidOperationException($"No path found from {query.ForAsset} to {query.DomAsset}");
        
        _log.Info("Price triangulation path : " + path.Aggregate(string.Empty, (s, tuple) => s + tuple + "->"));
        
        var timestamp = Instant.MinValue;
        foreach (var n in path)
        {
          var pathForDom = n.forAsset + n.domAsset;
          var isInverse = info.Pairs.Contains(n.domAsset + n.forAsset);
          if (isInverse)
            pathForDom = n.domAsset + n.forAsset;

          var pathResult = await _handler.Handle(new AssetPriceQuery(pathForDom));

          if (timestamp == Instant.MinValue)
            timestamp = pathResult.Timestamp;
          
          if ( pathResult.Timestamp.Minus(timestamp).Days > 0 )
            throw new InvalidOperationException($"Stale pricing date for {pathForDom}");

          if (isInverse)
            pathResult.Price = 1.0 / pathResult.Price;
          
          price *= pathResult.Price;
        }
      }
      
      return new GenericAssetPrice(price); 
    }
  }
}

